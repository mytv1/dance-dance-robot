package com.google.appengine.demos.dda.client;

import com.google.appengine.demos.dda.shared.DanceBeginMessage;
import com.google.appengine.demos.dda.shared.GameBeginMessage;
import com.google.appengine.demos.dda.shared.Message;
import com.google.appengine.demos.dda.shared.Step;
import com.google.gwt.animation.client.Animation;
import com.google.gwt.user.client.Timer;
import com.google.gwt.user.client.Window;
import com.google.gwt.user.client.ui.*;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * TODO(tobyr): Doc me
 *
 * @author Toby Reyelts
 */
public class GamePanel extends VerticalPanel {

  Image simonImage = new Image();
  Label gameLabel = new Label();
  Label timerLabel = new Label();
  List<String> players;
  // Map<String,Image> playerImages;
  static final int numRows = 4;
  static final int numColumns = 4;
  Grid playerGrid = new Grid(numRows, numColumns);
  String playerName;

  GamePanel(String playerName) {
    this.playerName = playerName;
    gameLabel.addStyleDependentName("gameLabel");
    gameLabel.setText("Get Ready!");
    add(gameLabel);
    timerLabel.addStyleDependentName("timerLabel");
    HorizontalPanel avatarPanel = new HorizontalPanel();
    add(avatarPanel);
    simonImage.setResource(Resources.instance.androidLargeImage());
    avatarPanel.add(simonImage);
    avatarPanel.add(playerGrid);
  }

  /**
   * Receives messages pushed from the server.
   */
  public void receiveMsg(Message msg) {
    switch (msg.getType()) {
      case GAME_BEGIN:
        beginGame((GameBeginMessage)msg);
      break;

      case MATCH_BEGIN:
      case ROUND_BEGIN:
      break;

      case DANCE_BEGIN:
        startDancing((DanceBeginMessage)msg);
      break;

      default:
        Window.alert("Unknown game type: " + msg.getType());
    }
  }

  private void beginGame(GameBeginMessage msg) {
    players = new ArrayList<String>(msg.getPlayers());
    players.add(0, playerName);
    int current = 0;
    for (int row = 0; row < numRows; ++row) {
      for (int column = 0; column < numColumns; ++column) {
        if (current >= players.size()) {
          break;
        }
        Image playerImage = new Image(Resources.instance.androidImage());
        String player = players.get(current);
        // playerImages.put(player, playerImage);
        VerticalPanel panel = new VerticalPanel();
        panel.add(playerImage);
        String shortPlayerName = player.substring(0, Math.min(10, player.length()));
        boolean truncated = player.length() > 10;
        if (truncated) {
          shortPlayerName += "...";
        }
        Label playerLabel = new Label(shortPlayerName);
        playerLabel.setWidth(playerImage.getWidth() + "px");
        playerLabel.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);
        panel.add(playerLabel);
        playerGrid.setWidget(row, column, panel);
        ++current;
      }
    }
    // do what here?
  }

  class DanceAnimation extends Animation {
    private List<Step> steps;
    double stepSize;

    void setDance(List<Step> steps) {
      this.steps = steps;
      stepSize = 1.0f / steps.size();
    }

    @Override
    protected void onUpdate(double progress) {
      double currentStep = progress / stepSize;
      if (currentStep >= steps.size()) {
        currentStep = steps.size() - 1;
      }
      Step step = steps.get((int)currentStep);
      simonImage.setResource(step.getLargeImage());
    }
  }

  private void startDancing(final DanceBeginMessage danceMsg) {
    gameLabel.setText("Watch!");
    final DanceAnimation animation = new DanceAnimation();
    animation.setDance(danceMsg.getSteps());
    animation.run(danceMsg.getTimeoutMillis() * 2);
    new Timer() {
      @Override
      public void run() {
        animation.cancel();
        receiveDance(danceMsg.getTimeoutMillis());
      }
    }.schedule(danceMsg.getTimeoutMillis() * 2 + 100);
  }

  private void receiveDance(long danceTimeoutMillis) {
    simonImage.setResource(Resources.instance.androidLargeImage());
    gameLabel.setText("Repeat!");
    startCountdownTimer(danceTimeoutMillis);
  }

  private void startCountdownTimer(long timeout) {
    long current = System.currentTimeMillis();
    final long deadline = current + timeout;
    new Timer() {
      @Override
      public void run() {
        long millisRemaining = deadline - System.currentTimeMillis();
        long secondsRemaining;
        if (millisRemaining > 0) {
          secondsRemaining = (long) (millisRemaining / 1000.0);
          if (secondsRemaining == 0) {
            secondsRemaining = 1;
          }
        } else {
          secondsRemaining = 0;
          cancel();
          gameLabel.setText("Get Ready!");
        }

        timerLabel.setText(String.valueOf(secondsRemaining));
      }
    }.scheduleRepeating(500);
  }
}
