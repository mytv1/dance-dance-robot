package com.google.appengine.demos.dda.client;

import com.google.appengine.demos.dda.client.channel.ImageMap;
import com.google.appengine.demos.dda.shared.*;
import com.google.gwt.animation.client.Animation;
import com.google.gwt.dom.client.NativeEvent;
import com.google.gwt.event.dom.client.ClickEvent;
import com.google.gwt.event.dom.client.ClickHandler;
import com.google.gwt.event.dom.client.MouseDownEvent;
import com.google.gwt.event.dom.client.MouseDownHandler;
import com.google.gwt.resources.client.ImageResource;
import com.google.gwt.user.client.Element;
import com.google.gwt.user.client.Timer;
import com.google.gwt.user.client.Window;
import com.google.gwt.user.client.rpc.AsyncCallback;
import com.google.gwt.user.client.ui.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * TODO(tobyr): Doc me
 *
 * @author Toby Reyelts
 */
public class GamePanel extends VerticalPanel {

  Image simonImage = new Image();
  Label gameLabel = new Label();
  List<String> players;
  Map<String,Image> playerImages = new HashMap<String,Image>();
  static final int numRows = 4;
  static final int numColumns = 4;
  Grid playerGrid = new Grid(numRows, numColumns);
  String playerName;
  boolean animating;
  HTML statusText = new HTML();
  GameServiceAsync gameService = GameService.App.getInstance();

  GamePanel(String playerName) {
    this.playerName = playerName;
    gameLabel.addStyleDependentName("gameLabel");
    gameLabel.setText("Get Ready!");
    add(gameLabel);
    HorizontalPanel avatarPanel = new HorizontalPanel();
    add(avatarPanel);
    simonImage.setResource(Resources.instance.androidLargeImage());
    avatarPanel.add(simonImage);
    avatarPanel.add(playerGrid);
    add(statusText);
  }

  /**
   * Receives messages pushed from the server.
   */
  public void receiveMsg(Message msg) {
    switch (msg.getType()) {
      case GAME_BEGIN:
        beginGame((GameBeginMessage)msg);
      break;

      case MATCH_BEGIN:
      case ROUND_BEGIN:
      break;

      case DANCE_BEGIN:
        startDancing((DanceBeginMessage)msg);
      break;

      case STEP_OCCURRED:
        stepOccurred((StepOccurredMessage)msg);
      break;

      default:
        Window.alert("Unknown game type: " + msg.getType());
    }
  }

  private void stepOccurred(StepOccurredMessage msg) {
    Image img = playerImages.get(msg.getPlayer());
    stepAnimate(img, msg.getStep(), false);
  }

  private void beginGame(GameBeginMessage msg) {
    players = new ArrayList<String>(msg.getPlayers());
    players.add(0, playerName);
    int current = 0;
    for (int row = 0; row < numRows; ++row) {
      for (int column = 0; column < numColumns; ++column) {
        if (current >= players.size()) {
          break;
        }
        Image playerImage = new Image(Resources.instance.androidImage());
        String player = players.get(current);
        playerImages.put(player, playerImage);
        VerticalPanel panel = new VerticalPanel();
        panel.add(playerImage);
        String shortPlayerName = player.substring(0, Math.min(10, player.length()));
        boolean truncated = player.length() > 10;
        if (truncated) {
          shortPlayerName += "...";
        }
        Label playerLabel = new Label(shortPlayerName);
        playerLabel.setWidth(playerImage.getWidth() + "px");
        playerLabel.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);
        panel.add(playerLabel);
        playerGrid.setWidget(row, column, panel);
        ++current;
      }
    }
    // do what here?
  }

  class DanceAnimation extends Animation {
    double stepSize;
    private DanceBeginMessage danceMsg;

    void setDance(DanceBeginMessage danceMsg) {
      this.danceMsg = danceMsg;
      stepSize = 1.0f / danceMsg.getSteps().size();
    }

    @Override
    protected void onUpdate(double progress) {
      int currentStep = (int) (progress / (stepSize / 2));
//      statusText.setHTML(statusText.getHTML() + "<br>Current step: " + currentStep + " progress: " + progress);
      if (progress == 0 || currentStep % 2 == 1) {
        simonImage.setResource(Resources.instance.androidLargeImage());
        return;
      }

      currentStep /= 2;
//      statusText.setText(statusText.getText() + "\nCurrent image step: " + currentStep);
      ImageResource image;
      if (currentStep >= danceMsg.getSteps().size()) {
        image = Resources.instance.androidLargeImage();
      } else {
        Step step = danceMsg.getSteps().get(currentStep);
        image = step.getLargeImage();
      }
      simonImage.setResource(image);
    }

    @Override
    protected void onComplete() {
      listenForDanceInput(danceMsg);
    }

    @Override
    protected double interpolate(double progress) {
      return progress;
    }
  }

  private void startDancing(final DanceBeginMessage danceMsg) {
    gameLabel.setText("Watch!");
    final DanceAnimation animation = new DanceAnimation();
    animation.setDance(danceMsg);
    animation.run(danceMsg.getTimeoutMillis());
  }

  private void listenForDanceInput(DanceBeginMessage danceMsg) {
    simonImage.setResource(Resources.instance.androidLargeImage());
    gameLabel.setText("Repeat!");
    simonImage.addMouseDownHandler(new MouseDownHandler() {
      public void onMouseDown(MouseDownEvent event) {
        // Keep the image from being selected when we accidentally
        // drag over it.
        event.preventDefault();
      }
    });
    simonImage.addClickHandler(new ClickHandler() {
      public void onClick(ClickEvent clickEvent) {
        if (animating) {
          return;
        }
        NativeEvent event = clickEvent.getNativeEvent();
        int x = getRelativeX(event, simonImage);
        int y = getRelativeY(event, simonImage);
        Step step = ImageMap.getStep(x, y);
        stepAnimate(simonImage, step, true);
      }
    });
    startCountdownTimer(danceMsg.getTimeoutMillis());
  }

  private void stepAnimate(final Image image, Step step, final boolean local) {
    if (step == null) {
      return;
    }

    if (local) {
      gameService.reportStep(playerName, step, new AsyncCallback() {
        public void onFailure(Throwable caught) {
          Window.alert(caught.getMessage());
        }
        public void onSuccess(Object result) {
        }
      });
      animating = true;
    }
    image.setResource(local ? step.getLargeImage() : step.getImage());
    new Timer() {
      @Override
      public void run() {
        image.setResource(local ? Resources.instance.androidLargeImage() : Resources.instance.androidImage());
        if (local) {
          animating = false;
        }
      }
      // NB(tobyr) Make this something not static?
    }.schedule(300);
  }

  private void startCountdownTimer(long timeoutMillis) {
    long current = System.currentTimeMillis();
    final long deadline = current + timeoutMillis;
    gameLabel.setText("Time remaining: " + (timeoutMillis / 1000) + " seconds");
    new Timer() {
      @Override
      public void run() {
        long millisRemaining = deadline - System.currentTimeMillis();
        int secondsRemaining = (int) ((millisRemaining / 1000.0) + 0.99);
        if (secondsRemaining > 0) {
          gameLabel.setText("Time remaining: " + secondsRemaining + " seconds");
        } else {
          cancel();
          gameLabel.setText("Time's up!");
        }
      }
    }.scheduleRepeating(300);
  }

  // NB(tobyr) Looks like an oversight that these don't exist in ClickHandler,
  // when they're available from MouseEvent (where we copied them from).
  private static int getRelativeX(NativeEvent event, Widget w) {
    Element target = w.getElement();
    return event.getClientX() - target.getAbsoluteLeft() + target.getScrollLeft() +
      target.getOwnerDocument().getScrollLeft();
  }

  private static int getRelativeY(NativeEvent e, Widget w) {
    Element target = w.getElement();
    return e.getClientY() - target.getAbsoluteTop() + target.getScrollTop() +
        target.getOwnerDocument().getScrollTop();
  }
}
